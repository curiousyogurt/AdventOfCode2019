;;;;
;;;; Advent of Code 2019: Day 2, Part 2
;;;; https://adventofcode.com/2019/day/2
;;;;
;;;; 1202 Program Alarm
;;;;
(ns day2a.n)

;;;
;;; Load in the data for the problem as a vector
;;;
(def input-data
  (mapv read-string
        (re-seq #"[\d.]+" (slurp "resources/day2.txt"))))

;;;
;;; Given a sequence of 4 integers, return the required operation as a function.
;;; Opcode 1 is addition; opcode 2 is multiplication.  Any other opcode returns
;;; nil.
;;;
(defn op
  [intcode position]
  (let [opcode (get intcode position)]
    (cond
      (= opcode 1) +
      (= opcode 2) *
      :else nil)))

;;;
;;; Pull an individual instruction (4 integers) from the intcode, starting at
;;; position.  The pattern is:
;;;
;;;   1: opcode (submit to op to get a function)
;;;   2: position in intcode of first value
;;;   3: position in intcode of second value
;;;   4: position for output
;;;
(defn execute
  [intcode position]
  (let [operation (op intcode position)
        val1 (get intcode (get intcode (+ position 1)))
        val2 (get intcode (get intcode (+ position 2)))
        out (get intcode (+ position 3))]
    (when-not (nil? operation)
      (assoc intcode out (operation val1 val2)))))

;;;
;;; Run the intcode.  Do this by starting at specified position.  If we get nil
;;; as a result, either we have hit opcode 99 (halt), or we have an unknown
;;; opcode; halt in either case.  Step through intcode 4 positions at a time.
;;;
(defn run
  [intcode position]
  (loop [intcode intcode
         position position]
    (let [result (execute intcode position)]
      (if (nil? result)
        intcode
        (recur result (+ position 4))))))

;;;
;;; Prepare a list of all combinations in two dimensions: between 0 and
;;; max-x; and between 0 and max-y (exclusive of max-x and max-y).
;;; This allows us to recurse 
;;;
(defn prepare-combinations
  [max-x max-y]
  (for [x (range 0 max-x)
        y (range 0 max-y)]
    (vector x y)))

;;;
;;; Prep the intcode by replacing position 1 (the noun) and position 2 (the
;;; verb).  By default, the noun is 12 and the verb is 2; but the noun and
;;; verb can be set to any value.
;;;
(defn prep
  ([intcode]
   (assoc (assoc intcode 1 12) 2 2))
  ([intcode noun verb]
   (assoc (assoc intcode 1 noun) 2 verb)))

;;;
;;; Find the noun and verb that generate the target.  Do this by brute-force
;;; recursion, going through all possible combinations (as generated by
;;; prepare-combinations).  For each noun and verb pair, calculate the result.
;;; Since we are guaranteed by the problem to find a solution, there is no
;;; need to test for (empty? combinations) to be true as part of the loop.
;;;
(defn find-noun-verb
  [intcode target]
  (loop [combinations (prepare-combinations 100 100)]
    (let [noun (first (first combinations))
          verb (last (first combinations))
          result (run (prep intcode noun verb) 0)]
      (if (= (first result) target)
        (list noun verb)
        (recur (rest combinations))))))

;;;
;;; Kick off the search (via find-noun-verb) and then perform the final
;;; calculation for the problem (noun * 100 + verb).
;;;
(defn calculate
  [intcode target]
  (let [result (find-noun-verb intcode target)]
    (+ (* (first result) 100) (last result))))

;;;
;;; Calculate the result
;;;
(calculate input-data 19690720)
